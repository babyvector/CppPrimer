# 第13章的内容笔记

## 13.1 拷贝、赋值与销毁

* 拷贝构造函数
  
    如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是控制拷贝函数。

        class Foo{
            public:
                Foo();          //默认构造函数
                Foo(const Foo&) //拷贝构造函数
                //...
        }

    **拷贝构造函数的第一个参数必须是一个引用类型**，虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。拷贝构造函数在几种情况下都会被隐式的使用。因此，拷贝构造函数通常不应该是explicit的
* 合成拷贝构造函数

* 拷贝初始化

    现在，我们可以完全理解直接初始化和拷贝初始化之间的差异了

        string dots(10, '.');   //直接初始化
        string s(dots);         //直接初始化
        string s2  = dots;      //拷贝初始化
        string null_book = "9-999-9999";//拷贝初始化
        string nines = string(100,'9'); //拷贝初始化

    当使用直接初始化时，我们**实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数**。当我们使用**拷贝初始化**时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换.

    拷贝初始化通常使用拷贝构造函数来完成。但是，如我们将在13.6.2节所见，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。但现在，我们只需了解拷贝初始化何时发生，以及拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的就可以了。

    拷贝初始化不仅在我们用=定义变量时会发生，**下列情况也会发生**：    

    * 将一个对象作为实参传递给一个非引用类型的型参
    * 从一个返回类型为非引用类型的函数返回一个对象
    * 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
  
    **某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用insert或push成员时，容器会对其元素进行拷贝初始化**。与之相对，用emplace成员创建的元素都进行直接初始化。

* 参数和返回值

    **注意**: 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。

    **拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型**(因为这个时候还没有拷贝构造函数供我们使用)。如果其参数不是引用类型，则调用永远也不会成功，为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。

* 拷贝初始化的限制

    如前所述，如果我们使用的初始化值要求通过一个explicit的构造函数进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的了：

    * vector<int> v1(10);//正确：直接初始化
    * vector<int> v2 = 10;//错误：接受大小参数的构造函数是explicit的
    * void f(vector<int>);//f的参数进行拷贝初始化
    * f(10);//错误：不能用一个explicit的构造函数拷贝一个实参
    * f(vector<int>(10))//正确：从一个int直接构造一个临时vector

    直接初始化v1是合法的，但看起来与之等价的拷贝初始化v2则是错误的，因为vector的接受单一大小参数的构造函数是explicit的。出于同样的原因，当传递一个实参或从函数返回一个值时，我们不能隐式使用一个explicit构造函数。如果我们希望使用一个explicit构造函数，就必须显式地使用，像此代码中的最后一行那样。

* 编译器可以绕过拷贝构造函数

    在拷贝初始化过程中，编译器可以(但不是必须)跳过拷贝/移动构造函数，直接创建对象。即，编译器被允许将下面的代码

        string null_book = "9-999-9999";//拷贝初始化

        改写为：

        string null_book("9-999-9999");//编译器略过了拷贝构造函数

    但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的(例如，不能是private的)


* 拷贝赋值运算符

    与类控制其对象如何初始化一样，类也可以控制其对象如何赋值：

    Sales_data trans, accum;
    trans = accum;//使用Sales_data的拷贝赋值运算符

    **与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个**
    
    * 重载赋值运算符

        赋值运算符就是一个名为operator=的函数。类似于任何其他函数，**运算符函数也有一个返回类型和一个参数列表**。

        重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。**如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数**。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。

        拷贝赋值运算符接受一个与其所在相同类型的参数：

                class Foo{
                    public:
                    Foo& operator=(const Foo&);//赋值运算符
                }

        **赋值运算符通常应该返回一个指向其左侧运算对象的引用**
    * 合成拷贝赋值运算符

        与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。**类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值,不会**如果拷贝赋值运算符并非出于此目的，它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一个工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

* 析构函数

    析构函数执行与构造函数相反的操作：析构函数初始化对象的**非static数据成员**，还可能做一些其他工作；析构函数释放使用的资源，并**销毁对象的非static数据成员**

    **由于析构函数不接受参数，因此不能够被重载。**对于一个给定的类，只会有唯一一个析构函数。析构函数会释放自己类内申请的相关动态内存并进行管理，但是在释放其他对象的时候会调用该对象的相应的析构函数。

* 三/五法则

    有三个基本操作可以控制类的拷贝操作：**拷贝构造函数、拷贝赋值运算符、析构函数.**而且，在新的标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。

    C++语言并不要求我们定义所有这些操作：可以只定义其中一个或两个，而不必定义所有。但是，这些操作通常情况下应该被看作一个整体。通常，只需要其中一个操作，而不需要定义所有操作的情况很少见。

    * 需要析构函数的类必定也需要拷贝和赋值操作

        当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显。**如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。**因为要进行控制拷贝和赋值才能避免出现一个内存块被delete多次的情况。

            class HasPtr{
                public:
                    HasPtr(const string &s = string()):
                    ps(new string(s)),i(0){}

                    ~HasPtr(){delete ps;}
                    //错误：HasPtr需要一个拷贝构造函数和一个拷贝赋值运算符
                    //其他成员的定义，如前
            };

        在这个版本的类定义中，构造函数中分配的内存将在HasPtr对象销毁时被释放。但不幸的是，我们引入了一个严重的错误！**这个版本的类使用了合成的拷贝构造函数和拷贝赋值运算符。这些函数简单拷贝指针成员**，这意味着多个HasPtr对象可能指向相同的内存：

            HasPtr f(HasPtr hp)//HasPtr是传值参数，所以将会被拷贝
            {
                HasPtr ret = hp;//拷贝给定的HasPtr
                //处理ret
                return ret;//ret和hp
            }

    * 需要拷贝操作的类也需要赋值操作，反之亦然

        虽然很多类需要定义所有（或是不需要定义任何）拷贝控制成员，但某些类所要完成的工作，只需要拷贝或赋值操作，不需要析构函数。

        **作为一个例子**，考虑一个类为每个对象分配一个独有，唯一的序号。这个类需要一个拷贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。**这个类还需要自定义拷贝赋值运算符来避免将序号赋予目的对象**。但是，这个类不需要自定义析构函数。

        这个例子**引出了第二个基本原则：**如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。

* 使用=default

    我们可以通过拷贝控制成员定义为=default来显式要求编译器生成合成的版本

        class Sales_data{
            public:
                //拷贝控制成员；使用default
                Sales_data() = default;
                Sales_data(const Sales_data&) = defult;
                Sales_data& operator=(const Sales_data &);
                ~Sales_data() = default;
                //其他成员的定义，如前
        }

        Sales_data& Sales_data::operator=(const Sales_data &) = default;

    当我们在类内用=default修饰成员的声明时，**合成的函数将隐式地声明为内联**(就像任何其他类内声明的成员函数一样)。**如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样**。

* 阻止拷贝

    虽然大多数类的应该定义（而且通常也的确定义了）拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或者赋值.例如，**iostream类阻止了拷贝，来避免多个对象写入或读取相同的IO缓冲**。为了阻止拷贝，不能不定义拷贝函数，这是错误的，因为类会帮我们自动生成。

    * 定义删除函数

        在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数(delete function)来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的

            struct NoCopy{
                NoCopy() = default;//使用合成的默认构造函数

                NoCopy(const NoCopy&) = delete;//阻止拷贝

                NoCopy & operator=(const NoCopy&) = delete;//阻止赋值

                ~NoCopy() = default;//使用合成的析构函数

                //其他成员
            }

        * 注意：

            * 与=default不同，=delete必须出现在函数的第一次声明
            * 任何函数都可以指定=delete但是对于=default(我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用)

    * 析构函数不能是删除的成员

        我们不能删除析构函数。**如果析构函数被删除，就无法销毁此类型的对象了**。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类型的临时变量或者创建该类型的临时对象。而且，如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。因为如果一个成员的析构函数是无法删除的，则该成员函数无法被删除。而如果一个成员无法被销毁，则对象的整体也就无法被销毁了。

        **对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象，但是不能释放这些对象：**

            struct NoDtor{
                NoDtor() = default;//使用合成默认构造函数
                ~NoDtor() = delete; //不能销毁NoDtor类型的对象
            }

            NoDtor nd;//错误：NoDtor的析构函数是删除的
            NoDtor *p = new NoDtor();//正确：但我们不能delete p
            delete p;//错误，其析构函数是被删除的。
    * 合成的拷贝控制成员可能是删除的(考虑到const和引用的情况)

        有几条内容暂时略去

        本质上这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、赋值、或销毁则对应的成员将被定义为删除的。

        一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的，这看起来可能有些奇怪。其原因是，如果没有这条规则，我们可能创建出无法销毁的对象。

        对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数，这应该不奇怪。同样不出人意料的规则是：如果一个类有const成员，则它不能使用合成的拷贝赋值运算符。毕竟，此运算符试图赋值所有的成员，而将一个新值赋予一个const对象是不可能的。

        **注意**：本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。

        **这里还有许多没有弄明白的地方**

    * private 拷贝控制

        在新的标准出来之前，一般都是使用private来禁止拷贝的，将相关的拷贝函数声明为私有，就可以控制拷贝。但是还有很多细节未知。

    
## 13.2 拷贝控制和资源管理

通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么几乎肯定也需要一个拷贝构造函数和一个拷贝复制函数。

为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。**一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针**。

  * 像值（重要类型：复制两份数据）

      类的行为像值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。

  * 像指针（重要类型：共享底层数据）

      行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。

  * 重要示例：

    当我们在使用标准库类中，**标准库容器和string类的行为像一个值**。而不出意外的，**shared_ptr类提供类似指针的行为**，就像我们的StrBlob类一样，IO类型和unique_ptr不允许拷贝或赋值，因此它们的行为**既不像值类型也不像指针类型**。

  * 注意点：

    **对于一个赋值运算符来说，正确工作是非常中要的，即使是将一个对象赋予它自身，也要能正常工作。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧对象。具体情况见作业13-22**

* 定义行为像指针的类

    对于这种类来讲，我们需要为其定义拷贝构造函数和赋值运算符，来拷贝指针成员本身而不是它指向的string。我们的类仍然需要自己的析构函数来释放接受string参数的构造函数分配的内存。

    令一个类展现类似指针行为的最好方法是使用shared_ptr来管理类中的资源。

  * 定义一个使用引用计数的类

    通过使用引用计数，我们就可以编写类指针的HasPtr版本了：
    
        class HasPtr{
            public:
                //构造函数分配新的string和新的计数器，将计数器置为1
                HasPtr(const std::string &s = std::string()):
                    ps(new string(s)),i(0),use(new size_t(1)){}
                //拷贝构造函数拷贝所有三个数据成员，并递增计数器
                HasPtr(const HasPtr &p):
                    ps(p.ps),i(p.i),use(p.use){++*use;}
                HasPtr& operator=(const HasPtr&);
                ~HasPtr();
            private:
                string *ps;
                int i;
                size_t *use;//用来记录有多少个对象共享*ps的成员

        }
        HasPtr::~HasPtr(){
            if(--*use == 0){//如果引用计数变为0
                delete ps;  //释放string内存
                delete use; //释放计数器内存
            }
        }
        HasPtr& HasPtr::operator=(const HasPtr &rhs){
            ++*rhs.use;     //递增右侧运算对象的引用计数
            if(--*use == 0){//然后递减对象的引用计数
                delete ps;  //如果没有其他用户
                delete use; //释放本地对象分配的成员
            }
            ps = rhs.ps;    //将数据从rhs拷贝到本对象
            i = rhs.i;
            use = rhs.use;
            return *this;   //返回本对象
        }

    在此，我们添加了一个名为Use的数据成员，它记录有多少个对象共享相同的string。接受string参数的构造函数分配新的计数器，并将其初始化为1，指出当前有一个用户使用本对象的string成员。



## 13.3 交换操作

* 在赋值运算符中使用swap

    定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为**拷贝并交换(copy and swap)**的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换：

            //注意rhs是按值传递的，意味着HasPtr的拷贝构造函数
            //将右侧运算对象中的string拷贝到rhs
            HasPtr& HasPtr::operator=(HasPtr rhs){
                //交换左侧运算对象和局部变量rhs的内容
                swap(*this,rhs);//rhs现在指向本对象曾经使用的内存
                return *this;   //rhs被销毁，从而delete了rhs中的指针
            }

            

## 13.4 拷贝控制示例

虽然通常来说分配资源的类更需要控制拷贝，但资源管理并不是一个类需要定义自己
的拷贝控制成员的唯一原因。一些类也需要拷贝控制成员的帮助**来进行薄记**工作
或其他操作

* **引用限定符：引用限定符可以是&或&&，分别指出this可以指向一个左值或右值。**如果同const一同出现，则其只能出现在const的后面。

## 13.5 动态内存管理类

## 13.6 对象移动

我们的StrVec类是这种不必要的拷贝的一个很好的例子。在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。使用移动而不是拷贝的另一个原因源于**IO类**或**unique_ptr**这样的类。这些类都包含不能被共享的资源(如指针或IO缓冲)。因此，这些类型的对象不能拷贝但可以移动。

* 13.6.1 右值引用

  * int &r = i;           //左值引用(对象)
  * int &&r = i*42;       //右值引用(结果)

          int i = 42;
          int &r = i;             //正确：r引用i
          int &&rr = i;           //错误：不能将一个右值引用绑定到一个左值上
          int &r2 = i*42;         //错误：i\*42是一个右值
          const int &r3 = i*42;   //正确：我们可以将一个const的引用绑定到一个右值上
          int &&rr2 = i*42;       //正确：将rr2绑定到乘法结果上

  * 为什么要引入右值引用：

      C++11中引入了右值引用和移动语义，可以避免无谓的复制，提高了程序的性能，右值引用标记为T&&。

          int &&rr3 = std::move(rr1);//OK

      move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。调用move之后，我们不能对移后源对象的值左任何假设 **???**.


* 移动构造函数和移动赋值运算符

    类似拷贝构造函数，移动构造函数的第一个参数是该类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。

    例子：

        StrVec::StrVec(StrVec && s) noexcept    //移动操作不应抛出任何异常
            //成员初始化器接管s中的资源（重要：接管）
            :elements(s.elements),first_free(s.first_free),cap(s.cap)
        {
            //令s进入这样的状态--对其运行析构函数是安全的
            s.elements = s.first_free = s.cap = nullptr;
        }

    * 合成的移动操作

        只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值的时候，编译器才会为他合成移动构造函数或移动赋值运算符。

    * 移动操作、标准库容器和异常

        由于移动操作窃取资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们将此事通知标准库。我们将看到，除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常。

        一种通知标准库的方法是在我们的构造函数中指明**noexcept**;位置和用法与const类似

    * 移动赋值运算符

        **注意点：移动赋值运算符不应该抛出异常，而且必须处理自赋值。**

            StrVec &StrVec::operator=(StrVec &&rhs) noexcept
            {
                //直接检测自赋值
                if(this != &rhs){
                    free();                         //释放已有元素
                    elements = rhs.elements;        //从rhs接管资源
                    first_free = rhs.first_free;    //
                    cap = rhs.cap;
                    //将rhs置于可析构状态????
                    rhs.elements = rhs.first_free = rhs.cap = nullptr;
                }
                return *this;
            }

            此例中，我们直接检查this指针与rhs的地址是否相同。如果相同右侧和左侧运算对象指向相同的对象，我们不需要做任何事情。否则，**我们释放左侧运算对象所使用的内存，并接管给定对象的内存**。与移动构造函数一样，我们将rhs中的指针置为nullptr。

    * 拷贝并交换赋值运算符和移动操作

            class HasPtr{
            public:
                    //添加的移动构造函数
                    HasPtr(HasPtr &&p) noexcept: ps(p.ps),i(p.i){p.ps = 0;}
                    //赋值运算符即是移动赋值运算符，也是拷贝赋值运算符
                    HasPtr& operator=(HasPtr rhs)
                        {swap(*this, rhs); return *this;}
                    //其他成员的定义，同13.2.1节            
            }

        在这个版本中，我们为类添加了一个移动构造函数，它接管了给定实参的值。构造函数体将给定的HasPtr的指针置为0，从而确保销毁移后源对象是安全的。此函数不会抛出异常，因此我们将其标记为noexcept

        现在让我们观察赋值运算符。此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数---------左值被拷贝，右值被移动?????。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。???????


       **(！以下这一段话十分重要：)**现在让我们观察赋值运算符。此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数-----左值被拷贝，右值被移动。因此，**单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能**。 

        例子：假如hp和hp2都是HasPtr对象

            hp = hp2;               //hp2是一个左值；hp2通过拷贝构造函数来拷贝
            hp = std::move(hp2);    //移动构造函数移动hp2

        **注意：调用拷贝构造函数还是移动构造函数是根据等号右边的对象的类型决定的。**

    * 建议：更新三/五法则

        所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。

    * 移动迭代器

        新标准库中定义了一种**移动迭代器(move iterator)适配器**一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。(也就是配合相应的算法能将拷贝操作转换为移动操作)

        值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。

    * 建议：不要随意适用移动操作