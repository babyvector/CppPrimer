# 第18章 用于大型程序的工具

与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更高。大规模应用程序的特殊要求包括：

   * 在独立开发的子系统之间协同处理错误的能力
   * 使用各种库（可能包含独立开发的库）进行协同开发的能力
   * 对比较复杂的应用概念建模的能力
以下三个就是针对上面的三种情况。


## 18.1 异常处理

****

### 18.1.1 抛出异常

在C++语言中，我们通过**抛出**一条表达式来**引发**一个异常。**被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码**将被用来处理该异常。

如我们所知，当一个异常被抛出时，沿着调用链的块将依次退出直到找到与异常匹配的处理代码。如果退出了某个块，则同时释放块中局部对象使用的内存。**因此，抛出一个指向局部对象的指针几乎肯定时一种错误的行为**。出于同样的原因，从函数中返回指向局部对象的指针也是错误的。

### 18.1.2 捕获异常

声明的类型决定了处理代码所能捕获的异常类型。**这个类型必须是完全类型，它可以是左值引用，但不能是右值引用**。

当进入一个catch语句后，通过异常对象初始化异常对象初始化异常声明中的参数。和函数的参数类似，**如果catch的参数类型是非引用类型，则该参数是异常对象的一个副本**，在catch语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异常对象。

* 异常说明与指针、虚函数和拷贝控制

   函数指针及该指针所指的函数必须具有一致的异常说明。
   
   如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；**与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常也可以不允许**

## 18.3 命名空间

   和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。**命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。**

   **命名空间作用域后面无须分号**。

* 每个命名空间都是一个作用域

   和其他作用域类似，命名空间中的每个名字都必须表示该空间的唯一实体。因为不同命名空间的作用域不同，所以在不同命名空间内可以有相同名字的成员。

* 命名空间可以是不连续的

   命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义类及函数的方式：

  *  命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件被包含在使用了这些成员的文件中。
  *  命名空间成员的定义部分则置于另外的源文件中。

* 注意：定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型（或关联类型构成的集合）

* 注意:在通常情况下，我们不把#include放在命名空间内部。如果我们这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。

* 内联命名空间

   C++11新标准引入了一种新的嵌套命名空间，成为内联命名空间和普通的嵌套命名空间不同，内联命名空间中的名字可以被外层命名空间直接使用。也就是说，我们无须再内联命名空间的名字前面添加表示该命名空间的前缀，通过外层命名空间的名字就可以直接访问它。

   定义内联命名空间的方式是在关键字namespace前添加关键字inline

         inline namespace FifthEd{
            //该命名空间表示书本第5版的代码
         }

         namespace FifthEd{//隐式内联
            class Query_base{/**/};
            //其他与Query有关的声明
         }

### 18.2.2 使用命名空间成员

* 命名空间的别名

   命名空间的别名使得我们可以为命名空间的名字设定一个短的多的同义词。

         namespace primer = cplusplus_primer;

         namespace Qlib = cplusplus_primer::QueryLib;
         
         Qlib::Query q;

* using 声明：扼要概述

   一条using声明语句一次只引入命名空间的一个成员。它使得我们可以清除的知道程序中所用的到底是哪个名字。

      using std::cout;

* using 指示：快速的注入全部变量

      using namespace std;

### 18.2.3 类、命名空间与作用域

   对命名空间内部名字的查找遵循常规的查找规则：**即由内向外依次查找每个外层走用于。外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过程终止**。只有位于开放的块中且在使用点之前声明的名字才被考虑。

* 实参相关的查找与类类型形参
* 查找与std::move和std::forward
* 友元声明与实参相关的查找

   当类声明一个友元时，该友元声明并没有使得友元本身可见。然而，一个另外的未声明的类或函数如果第一次出现在友元声明中，则我们认为它是最近的外层命名空间的成员。这条规则与实参相关的查找规则结合在一起将产生意想不到的效果：

         namespace A{
            class C{
               //两个友元，在友元声明之外没有其他声明
               //这些函数隐式地成为命名空间A的成员
               friend void  f2()    //除非另有声明，否则不会被找到
               friend void  f(const C&)      //根据实参相关的查找规则可以被找到

            };
         }

   此时，f和f2都是命名空间A的成员。即使f不存在其他声明，我们也能通过实参相关的查找规则调用f：

         int main(){
            A::C cobj;
            f(cobj);    //正确：通过在A：：C中的友元声明找到A::f
            f2();       //错误：A::f2没有被声明
         }

   因为f接受一个类类型的实参，而且f在C所属的命名空间进行了隐式的声明，所以f能被找到。相反，因为f2没有形参，所以它无法被找到。

### 18.2.4 重载与命名空间

* 与实参相关的查找与重载

   在上一节中我们了解到，**对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行**。这条规则对于我们如何确定候选函数集同样也有影响。**我们将在每个实参类(以及实参类的基类)所属的命名空间中搜寻候选函数**。在这些命名空间中所有与被调用函数同名的函数都将被添加到候选集当中，即使其中某些函数在调用语句处不可见也是如此。

         namespace NS{
            class Quote{/*...*/};
            void display(const Quote&){/*...*/}
         }
         //Bulk_item的基类声明在命名空间NS中
         class Bulk_item:public NS::Quote{/*...*/};
         int main(){
            Bulk_item book1;
            display(book1);
            return 0;
         }

   我们传递给display的实参属于类类型Bulk_item，因此该调用语句的候选函数不仅应该在调用语句所在的作用域中查找，而且也因该在Bulk_item及其基类Quote所属的命名空间中查找。命名空间NS中声明的函数display(cons Quote&)也将被添加到候选函数集当中。

* 重载与using声明(!!重点)

   想要理解using声明与重载之间的交互关系，必须明确一条：**using声明语句声明的是一个名字，而非一个特定的函数**

         using NS::print(int);      //错误：不能指定形参列表
         using NS::print            //正确：using声明只声明一个名字

   **当我们为函数书写using声明时，该函数的所有版本都被引入到当前的作用域中**

* 重载与using指示

   using指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域的函数名相同，则命名空间的函数将被添加到重载集合中。

   namespace libs_R_us{
      extern void print(int);
      extern void print(double);
   }
   //普通的声明
   void print(const std::string &);
   //这个using指示把名字添加到print调用的候选函数集
   using namespace libs_R_us;
   //print调用此时的候选函数包括：
   //lib_R_us的print(int)
   //libs_R_us的print(double)
   //显式声明的print(const std::string &)

   void fooBar(int ival){
      print("Value:");      //调用全局函数print(const string&)
      print(ival);          //调用libs_R_us::print(int)
   }

* 跨越多个using指示的重载

   如果存在多个using指示，则来自每个命名空间的名字都会成为候选函数集的一部分：

         namespace AW{
            int print(int);
         }
         namespace Primer{
            double print(double);
         }
         //using 指示从不同的命名空间中创建了一个重载函数集合
         using namespace AW;
         using namespace Primer;
         long double print(long double);
         int main(){
            print(1);      //调用AW::print(int)
            print(3.1);    //调用Primer::print(double)
            return 0;
         }

### 多重继承与虚继承

多重继承是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父亲的属性。尽管概念上非常简单，**但是多个基类相互交织产生的细节可能会带来错综复杂的设计问题与实现问题**

### 18.3.1多重继承

class Bear:public ZooAnimal
class Pandan:public Bear, public Endangered{/*...*/}

* 多重继承的派生类从每个基类中继承状态

   在多重继承关系中，派生类的对象包含有每个基类的子对象，**在Panda对象中含有一个Bear部分(其中又含有一个ZooAnimal部分)**一个Endangered部分以及在Panda中声明的非静态数据成员。

* 派生类构造函数初始化所有基类
* 继承的构造函数与多重继承
* 析构函数与多重继承

和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。

析构函数的调用顺序正好与构造函数相反，在我们的例子中，析构函数的调用顺序是~Panda,~Endangered,~Bear,~ZooAnimal

* 多重继承的派生类的拷贝与移动操作

   