# 第15章 面向对象程序设计

## 15.1 OOP：概述
* 面向对象程序设计的核心思想使**数据抽象**、**继承**、和**动态绑定**：
  * 通过使用数据抽象，我们可以将类的接口与实现分离（例如：我们可以使用抽象类的方式将接口向上抽离一层，这样对应的功能发生改变的时候不用整体编译代码，而只是需要编译代码的实现部分就好了。<可以自己找个例去实现>）
  * 使用继承，可以蒂尼工艺相似的类型并对其相似关系建模
  * 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用他们的对象。（在C++语言中，当我们使用**基类的引用（或指针）**调用一个**虚函数**时将**发生动态绑定**。）


## 15.2 定义基类和派生类

### 15.2.2定义派生类
* 派生类中的虚函数（派生类经常但不总是覆盖它继承的虚函数）
* 派生类对象及派生类向基类的**类型转换**
  * **我们能把派生类的对象当作基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上**
  
        Quote item                      //基类对象
        Bulk_quote bulk;                //派生类对象
        Quote *p = &item;               //p指向Quote对象
        p = &bulk;                      //p指向bulk的Quote部分
        Quote &r = bulk;                //r绑定到bulk的Quote部分
* 派生类构造函数
  * 派生类中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它的基类部分。**每个类控制自己成员初始化过程**
  * **Note:**首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。（除非我们特别指出否则派生类对象的基类部分会像数据成员一样执行默认初始化）

* 派生类在初始化的过程中要**尊重基类的接口**（就是不要直接赋值基类的成员而是用基类的接口初始化）

* 继承与静态成员：若基类中有静态成员，无论从基类中派生出来多少个派生类，在整个继承体系中只存在该成员的唯一定义。
* 被用作基类的类必须是已经定义过的（如果仅仅被声明过则不合格）
* 如何防止继承？使用final关键字  
  * class NoDerived final{};//NoDerived不能作为基类
  * class Last final:Base{};//Last不能作为基类

### 15.2.3 类型转换与继承

* 理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。
* 通常情况下，如果我们**想把引用或指针绑定到一个对象上**，则**引用或指针的类型应与对象的类型一致**，或者**对象的类型含有一个可接受的const类型转换规则**。但是存在继承关系的类是一个重要的例外。
* 静态类型与动态类型
    当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。**动态类型直到运行时才可知。**

* **总结：**要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：
  * **从派生类向基类的类型转换只对指针或引用类型有效**
  * **基类向派生类不存在隐式类型转换**(但是我们可以使用static_cast来屏蔽编译器进行的类型转的检查)
  * **和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行**
  * **尽管自动类型转换只对指针或引用类型有效**，但是继承体系中的大多数类仍然（显式或隐式地）定义了拷贝控制成员。**因此，我们通常能将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分**。

## 15.3 虚函数

* **（关键概念：C++的多态性）注意：**当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。
* 虚函数衍生的说明符
  * override说明符
    * 派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这样合法；编译器将认定新定义的这个函数与基类中原有的函数是相互独立的。C++11新标准中我们可以使用override关键字来说明派生类型的虚函数。**这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误**。

  * final说明符
    * 我们还能把某个函数指定为final，如果我们已经把函数定义为final了，则之后任何尝试覆盖该函数的操作都将引发错误：

  * final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后

  * 虚函数与默认实参
    * 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。（如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此）

* 回避虚函数的机制
  * double undiscounted = baseP->Quote::net_price(42);该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是什么。
  * 什么时候要使用回避虚函数的机制：**通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时**。

## 15.4 抽象基类

* 纯虚函数
  * 和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）加上=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。
  * 
        class Disc_quote:public Quote{
        public:
            Disc_quote() = default;
            Disc_quote(const string& book, double price,
                       size_t qty, double disc):
                       Quote(book, price),
                       quantity(qty), discount(disc){}
            double net_price(size_t) const = 0;
        protected:
            size_t quantity = 0;        //折扣适用的购买量
            double discount = 0.0;      //表示折扣的小数值
        };

    * 注意：我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部（我们不能在类的内部为一个=0的函数提供函数体）

* 含有纯虚函数的类时抽象基类->我们不能（直接）创建一个抽象基类的对象

### 关键概念：重构:
**在Quote的继承体系中增加Disc_quote类是重构(refactoring)的一个典型示例。重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。值得注意的是，即使我们改变了整个继承体系，哪些使用了Bulk_quote或Quote的代码也无须进行任何改动。不过一旦类被重构，我们必须重新编译含有这些类的代码**(注意：不用改动代码，但是要重新编译)。

* 关于protected的解读：
  * 希望成员变量被派生类共享，但是不想被其他公共访问。
  * 和私有成员类似，受保护的成员对于**类的用户**来说是不可访问的
  * 派生类的成员或友元只能通过派生类对象来访问基类中的受保护的成员，而不能跨过派生类来直接访问基类的受保护的成员（或者私有的成员）
  * **上面一段话可以表述为：派生类成员和友元只能访问派生类对象中的基类部分的受保护的成员；对于普通的基类对象中的成员不具有特殊的访问权限。**

* 关于class A : 限定符 class B 的解读
  * 限定符的作用并不是用来限定派生类对象，而是用来限定派生类对象的成员的访问权限。
* 类的用户分为三种：类的实现者、派生类、类的用户
  * public作为公共接口所有人都可以使用
  * protected作为受保护的成员实现者和派生类可以使用
  * private作为私有成员只有类的实现者可以使用
* 友元的继承
  * 友元关系即不能传递也不能继承
* 默认的继承保护级别
  * class关键字定义的派生类是私有继承的，而struct关键字定义的是公有继承的。
* struct与class除了默认的继承保护级别有差别其余的都是没有区别的

* **NOTE:关于派生类向基类转换的可访问性问题：**
  * 对于用户代码：只有当D公有地继承B时，用户代码才能使用派生类向基类的转换
  * 对于成员函数和友元：无论什么样的继承方式都能使用派生类向基类的转换
  * 对于派生类的成员函数和友元:如果D继承B的方式是公有的或者受保护的则可以类型转换，如果是私有的则不能。
## 15.5 访问控制与继承
## 15.6 继承中的类作用域

* itemP的类型时Quote的指针，意味着对discount_policy的搜索将从Quote开始

        Bulk_quote bulk;
        Quote *itemP = &bulk;
        itemP->discount_policy();//错误：discount_policy定义在Bulk_quote中，从Quote中开始搜索则搜索不到

* 派生类中成员的名字会隐藏基类中成员（包括变量和函数）的名字（当函数同名就算参数列表不相同也会进行覆盖）
* 可以通过作用域运算符来使用隐藏的成员（但是最好不要定义重复的名字）
* 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。
* 使用using对覆盖重载的函数


## 15.7 构造函数与拷贝控制
#### 15.7.1虚析构函数
* **注意：**如果基类的析构函数不是一个虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。
* 虚析构函数将阻止合成移动操作
* 和构造函数及复制运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源

#### 15.7.4继承的构造函数
* 一个类只能继承其直接基类的构造函数，类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成他们。
## 15.8 容器与继承
* 不能把具有继承关系的多种类型的对象直接存放到容器当中。
* 可以在容器中放置指针（或者智能指针）而非对象。
## 15.9 文本查询程序再探





## 定义基类

基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

## 15.5访问控制与继承

* 友元与继承

    就像友元关系不能传递一样，友元关系同样也不能继承基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。

* 改变个别成员的可访问性

    有时我们需要改变派生类继承的某个名字的访问级别，通过使用using声明可以达到这一目的。

    通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。也就是说，如果一条using声明语句出现在类的private部分，则类的所有用户都能访问它：如果using声明语句位于Protected部分，则该名字对于成员、友元和派生类是可访问的。

* class与struct

    struct和class关键字之间没有特殊的差别。唯一的差别就是默认成员访问说明符及默认派生访问说明符；除此之外，再无其他不同的地方。

        struct D1: Base{}
            //默认Public继承
        class D2: Base{}
            //默认private继承

* 名字冲突时的调用原则
    派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域的名字将会被外层的重名的对象所掩盖（即使参数列表并不相同）；在调用的时候可以用BASE::mem()来进行调用


        struct Base{
            int memfcn();
        };
        struct Derived:Base{
            int memfcn(int);//隐藏基类中的memfcn
        };
        Derived d; Base b;
        b.memfcn();         //调用Base::memfcn
        d.memfcn(10);       //调用Derived::memfcn
        d.memfcn();         //错误:参数列表为空的memfcn被隐藏了
        d.Base::memfcn();   //正确:调用Base::memfcn


* 虚函数与作用域

    我们现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表。假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。

        class Base{
        public:
            virtual int fcn();
        };

        class D1:public Base{
        public:
            //隐藏基类的fcn，这个fcn不是虚函数
            //D1继承了Base::fcn()的定义
            int fcn(int);       //形参列表与Base中的fcn不一致
            virtual void f2();  //是一个新的虚函数，在Base中不存在
        };

        class D2:public D1{
        public:
            int fcn(int);       //是一个非虚函数，隐藏了D1::fcn(int)
            int fcn();          //覆盖了Base的虚函数fcn
            void f2();          //覆盖了D1的虚函数f2
        }

    D1的fcn函数并没有覆盖Base的虚函数fcn，原因是它们的形参列表不同。实际上，D1的fcn将隐藏Base的fcn。此时拥有了两个名为fcn的函数：一个是D1从Base继承而来的虚函数fcn；另一个是

* 虚析构函数

    和其他虚函数一样，析构函数的虚属性也会被继承。因此，无论Quote的派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数。只要基类的析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本。

            Quote *itemP = new Quote;       //静态类型与动态类型一致
            delete itemP;                   //调用Quote的析构函数
            itemP = new Bulk_quote;         //静态类型与动态类型不一致
            delete itemP;                   //调用Bulk_quote的析构函数
    
    **注意：如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。**

* 派生类的拷贝控制成员
  * 定义派生类的拷贝或移动构造函数

        class Base{/**/};
        class D:public Base{
        public:
            //默认情况下，基类的默认构造函数初始化对象的基类部分
            //要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中显式的调用该构造函数
            D(const D&d):Base(d)    //拷贝基类成员
                        /*D的成员的初始值*/{/*...*/}
            D(D && d):Base(std::move(d))//移动基类成员
                        /*D的成员的初始值*/{/*...*/}
        };

  * 派生类赋值运算符

        与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值

            //Base::operator=(const Base&)不会被自动调用

            D &D::operator=(const D&rhs){
                Base::operator=(rhs);   //为基类部分赋值
                //按照过去的方式为派生类的成员赋值
                //酌情处理自赋值及释放已有的资源等情况
                return *this;
            }

  * 派生类析构函数

        在析构函数体执行完后，对象的成员会被隐式的销毁。类似的，对象的基类部分也是隐式的销毁的。**因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：**

            class D:public Base{
            public:
                ~D(){/*该处由用户定义清除派生类成员的操作*/}
                //Base::~Base被自动调用执行
            };

        **对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。**

  * 构造函数的继承性

    在C++11标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以非常规的方式继承而来，但是为了方便，我们不妨姑且称其为"继承"的。


    一个类只能继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。**如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们**。

* 15.8容器与继承

    当派生类对象被赋值给基类对象时，其中的派生类部分将被"切掉"，因此容器和存在继承关系的类型无法兼容。

    **注意：要在容器中放置（智能）指针而非对象**


    



