# 第14章

## 算术和关系运算符

* 算术运算符
    通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。**因为这些运算对象不需要改变运算对象的状态，所以形参都是常量的引用**。
* 关系运算符 <
    如果存在**唯一一种逻辑可靠的<**定义，则应该考虑为这个类定义<运算符。如果类同时还包含==,则当且仅当<的定义和==产生的结果一致时才定义<运算符

## 赋值运算符=

* 赋值运算符
    我们可以重载赋值运算符。不论形参的类型是什么，**赋值运算符都必须定义为成员函数**。

* 复合赋值运算符
    复合赋值运算符**不非得是类的成员**，不过我们还是**倾向于把包括复合赋值在内所有赋值运算都定义在类的内部**。为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要**返回其左侧运算对象的引用**。

## 下标运算符[]

 * **下标运算符必须是成员函数**。

 * 为了与下标的原始定义兼容，**下标运算符通常以所访问元素的引用作为返回值**，这样做的好处是**下标可以出现在赋值运算符的任意一端**。进一步，我们最好同时定义下标运算符的常量版本和非常量版本，当作用一个常量对象时，**下标运算符返回常量引用以确保我们不会给返回的对象赋值**。

 * 如果一个类包含下标运算符，则它通常会定义两个版本：**一个返回普通引用**，**另一个是类的常量成员并返回常量引用**。

    const StrVec a;
    a[1]访问的就是常量版本返回的是const string&, 我们不能够在外面改写b[1]; b[1] = "your name" 无法执行

    const StrVec b;
    b[1]访问的就是非常量版本 string，我们能够在外面改写b[1]; eg: b[1] = "your name"

## 递增和递减运算符

* 建议：定义递增和递减运算符的类应该同时定义前置版本和后置版本。**这些运算符通常应该被定义成类的成员**。
* 递增和递减的工作机理：**先检查**类是否有效，如果有效**再检查**给定的索引值是否有效，如果两者都是有效的则运算符返回对象的引用。

    前置递增的代码：
        StrBlobPtr& operator++();
        StrBlobPtr& StrBlobPtr::operator++(){
            //如果curr已经指向了容器的尾后位置，则无法递增它
            check(curr, "increment past end of StrBlobPtr");
            ++curr; //将curr在当前状态下向前移动一个元素
            return *this;
        }
    后置递增的代码：
        StrBlobPtr operator++(int);
        StrBlobPtr StrBlobPtr::operator++(int){
            //此处无须检查有效性，调用前置递增运算时才需要检查
            StrBlobPtr ret = *this;     //记录当前的值
            ++*this;                    //这里其实调用的是前置的递增运算符；在前置递增运算符中会检查递增的有效性
            return ret;                 //返回之前记录的状态。
        }

## 成员访问运算符 * ->

* **箭头运算符必须是类的成员。解引用运算符通常也是类的成员**，尽管并非必须如此。

* 值得注意的是我们将两个运算符定义成了const 成员，这是因为与递增和递减运算符不一样，获取一个元素并不会改变StrBlobPtr对象的状态。

* 对箭头运算符返回值的限定
  * 我们能令operator*完成任何我们指定的操作。比如我们可以让operator\*返回一个固定值42，或者打印或者其他；但是->运算符不是这样的，它永远不能丢掉成员访问这个最基本的含义**当我们重载箭头时，可以改变的是箭头从哪个对象当中获取成员，而箭头获取成员这一实时则永远不变。**

* point->mem的执行过程
  1. **如果point是指针**，则我们应用内置的箭头运算符，表达式等价于(*point).mem。首先解引用该指针，然后从所得的对象中获取指定的成员。如果point所指的类型没有名为mem的成员，程序会发生错误。
  2. **如果point是定义了operator->的类的一个对象**， 则我们使用point.operator->()的结果来获取mem。其中，如果该结果是一个指针，则执行第1步；如果该结果本身含有重载的operator->(),则重复调用当前步骤。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息。

* **注意：**重载的箭头运算符**必须**返回**类的指针**或者**自定义了箭头运算符的某个类的对象**

## 函数调用运算符（比较重要）

### ()

* 如果重载了函数调用运算符，则**我们可以像使用函数一样使用该类的对象**。因为**这样的类同时也能存储状态**，所以与普通函数相比他们**更加灵活**。
* **注意：**函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符，相互之间应该在参数上有所区别。
* 可调用对象与function
    C++语言中有几种可调用的对象：**(1)函数、(2)函数指针、(3)lambda表达式、(4)bind创建的对象以及(5)重载了函数调用运算符的类**

    * 不同类型可能具有相同的调用形式
        对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型。例如，考虑下列不同类型的可调用对象：
            //普通函数
            int add(int i, int j){return i+j;}
            //lambda,其产生一个未命名的函数对象类
            auto mod = [](int i, int j){return i%j; }
            //函数对象类
            struct divide{
                int operator()(int denominator, int divisor){
                    return denominator / divisor;
                }
            };

        上面这些可调用对象分别对其参数执行了不同的算术运算，尽管它们的类型各不相同，但是共享同一种调用形式：

            int(int, int)

### lambda

        for_each(vs.begin(), vs.end(), PrintString(cerr, '\n'))

    lambda是函数对象，在前一节中，我们使用一个PrintString对象作为调用for_each的实参，这一用法类似于我们在10.3.2节中编写的带有lambda表达式的程序。**当我编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中包含有一个重载的函数调用运算符**

### 标准库中定义的函数对象
    标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。
    
    * 例如，plus类定义了一个函数调用运算符用于对一对运算对象执行+操作；
    * modulus类定义了一个调用运算符执行二元的%操作
    * equal_to类执行==等等
    
    在算法中使用标准库函数对象：
    * 表示运算符的函数对象类常用来替换算法中的默认运算符。例如

        sort(svec.begin(), svec.end(), greater<string>());

### C++中的可调用对象总结和function类的作用

C++语言中有几种可调用的对象：**函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类**；对于以上几种类型的函数他们**拥有相同的函数调用形式**却没有相同的类型。因此如下例

        //普通函数
        int add(int i, int j){return i+j;}
        //lambda其产生一个未命名的对象
        auto mod = [](int i, int j){return i%j;}
        //函数对象类
        struct divide{
            int operator()(int denominator, int divisor){
                return denominator/divisor;
            }
        }

他们的最终的函数调用形式是相同的都是

        int (int,int);

的形式，但是我们无法把他们都放到下面的map中

        map<string, int(int,int)>binops;
    
**这个时候function模板类出现了**可以执行下面的操作：

        map<string, function<int(int, int)>>binops = 
        {
            {"+", add},                                 //函数指针
            {"-", std::minus<int>()},                   //标准函数库对象
            {"*", [](int a, int b){return a*b;}},       //未命名的lambda
            {"/", divide()},                            //用户定义的函数对象
            {"%", mod}                                  //命名了的lambda对象
        };

这样以来，我们就能将调用形式相同的函数放在一个集合中进行调用。


## 重载、类型转换与运算符

### 类型转换

* 定义含有类型转换运算符的类
    
    类型转换运算符：operator type() const;其中type表示某种类型。**类型转换运算符可以面向任意类型（除void之外）进行定义，只要该类型能作为函数的返回类型**。因此，我们**不允许转换成数组或者函数类型**，**但是允许转换成指针（包括数组指针和函数指针）或者引用类型**。

    例子：
        class SmallInt{
        public:
            SmallInt(int i = 0):val(i){
                if(i < 0 || i > 255)
                    throw std::out_of_range("Bad SmallInt value");
            }
            operator int() const {return val;}
        private:
            std::size_t val;
        }

    我们的SmallInt类既定义了向类类型的转换，也定义了从类类型向其他类型的转换。其中，构造函数将算术类型的值转换成SmallInt对象，而类型转换运算符将SmallInt对象转换成int

        SmallInt si;
        si = 4;                 //首先将4隐式地转换成SmallInt,然后调用SmallInt::operator=
        si + 3;                 //首先将si隐式地转换成int，然后执行整数的加法

    **注意：避免过度适用类型转换函数**

* 因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能再类型转换运算符中使用任何形参
* 类型转换运算符没有返回类型
* 类型转换运算符可能产生意外结果（再实践中，类很少提供类型转换运算符）

* **显式的类型运算符**

        int i = 42;
        cin<<i;//如果向bool的类型转换不是显式的，则该代码在编译器看来将是合法的

        这段程序试图将输出运算符作用于输入流。因为istream本身并没有定义<<，所以本来代码应该产生错误。然而，该代码能适用istream的bool类型转换符将cin转换成bool，而这个bool值接着会被提升成int并用作内置的左移运算符的左侧运算对象。这样一来，提升后的bool值(1或0)最终会被左移42个位置。这一结果显然与我们的预期大相径庭。

    为了防止出现这样的异常的现象发生，C++11新标准引入了**显式的类型转换运算符**

        class SmallInt{
        public:
            //编译器不会自动执行这一类型转换
            explicit operator int() const{return val;}
            //其他成员与之前的版本一致
        };

    和显式的构造函数一样，编译器（通常）也不会将一个显式的类型转换运算符用于隐式类型转换：

        SmallInt si = 3;                //正确：SmallInt的构造函数不是显式的
        si + 3;                         //错误：此处需要隐式的类型转换，但类的运算符是显式的
        static_cast<int>(si)+3;         //正确：显式地请求类型转换

    **当类型转换运算符是显式的时候，我们也能执行类型转换，不过必须通过显式的强制类型转换才可以。**

* 显式的类型转换会在特定的位置被隐式的转换
    * if while及do语句的条件部分
    * for语句的头的表达式
    * 逻辑非运算符! 、逻辑或运算符||、逻辑与运算符&&、的运算对象
    * 条件运算符（？：）的条件表达式

* 转换尾bool
  * 比较有名的例子是while(std::cin>>value){};输入流中定义了，向bool转换的类型转换运算符

* 避免有二义性的类型转换
  * 有两种情况下可能产生多重转换路径
    * 第一种情况是两个类提供相同的类型转换：例如，当A类定义了一个接受B类对象的**转换构造函数**，同时B类定义了一个转换目标是A类的**类型转换运算符**时，我们就说他们提供了相同的类型转换


            #include <iostream>

            using namespace std;

            struct B;
            struct A{
                A() = default;
                A(const B&);    //把一个B转换成A
                //其他数据成员
            };

            struct B{
                operator A() const; //也是把一个B转换成A
                //其他数据成员
            };


            int main(){
                
                A f(const A&);
                B b;
                A a = f(b);

                //B b都是要转换为类型A
                //但是是用  A的构造函数，还是用B的类型转换符？
                //由此产生了二义性


                return 0;

            }

    * 第二种情况是类**定义了多个转换规则**，而**这些转换涉及的类型本身可以通过其他类型转换联系在一起**。最典型的例子是算术运算符，对某个给定的类来说，最好只定义最多一个与算术类型有关的转换规则

* **最终总结：除了显式的向bool类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数。**

* 重载函数与转换构造函数（产生二义性冲突）
* 重载函数与用户定义的类型转换函数（产生二义性冲突）
  * 如果我们对一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题
  * 例子：
  
        class SmallInt{
            friend
            SmallInt operator+(const SmallInt&, const SmallInt&);
        public:
            SmallInt(int = 0);                          //转换源为int的类型转换
            operator int() const{return val;}           //转换目标为int的类型转换
        private:
            std::size_t val;    
        };
        SmallInt s1, s2;
        SmallInt s3 = s1 + s2;      //使用重载的operator+
        int i = s3 + 0;             //二义性错误

    第二条加法语句具有二义性：**因为我们可以把0转换为SmallInt**，然后使用SmallInt的+：**或者把s3转换成int**，然后对于两个int执行内置的加法运算。