# 第16章 模板与泛型编程

* 总体叙述1：模板是C++泛型编程的基础。一个模板就是一个创建**类**或**函数**的蓝图或者说公式。当使用一个vector这样的泛型类型，或者find这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。**这种转换发生在编译时**。

* 总体叙述2：当我们调用一个函数模板时，**编译器（通常）用函数实参**来为我们推断模板实参。编译器用推断出的模板函数来为我们**实例化**一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新的"实例"。

## 函数模板
### 实例化函数模板
* 函数模板能够在用户调用的时候，由编译器自行推断

## 类模板
### 实例化类模板
* 类模板不能由编译器来自行推断，只能靠用户提前给出

### 类模板的成员函数
* 与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，**且定义在类模板内的成员函数被隐式声明为内联函数**。
* 类模板的成员函数具有和模板相同的模板参数。所以，定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表。
* **注意：在默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。**
* 在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。

### 类模板和友元
* 友元可以是模板或者不是模板，当一个类模板的友元是模板的时候，可以授权给模板的一个实例，或者授权给模板的所有实例。
* 一对一友好关系：类模板之间建立友好关系的常见形式是：建立对应实例及其友元间的友好关系；比如Blob<int> 与 BlobPrt<int>是友元关系
### 模板类型别名：
  * 示范1:typedef Blob<string> StrBlob;
  * 示范2：template<typename T>using twin = pair<T, T>  ->使用twin<string> authors; //authors是一个pair<string, string>

### 类模板的static成员
* 类模板的每个实例都有一个独有的static对象；所有实例的对象共享一个static成员（可以是变量，也可以是函数）
* static成员的访问有两种方式：
  * Foo<int> fi;    -> auto ct = Foo<int>::count();
  * ct = fi.count();

## 16.1.3 模板参数

## 16.2.1 类型转换与模板类型参数
* 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。
  * 举一个例子的用法：**也就是说：使用模板类函数的时候可能发生类型转换，但是只允许有限的几种类型转换。**
  
        template<typename T>T fobj(T,T);//实参被拷贝
        template<typename T>T fref(const T&, const T&);//引用
        string s1("a value");
        const string s2("another value");
        fobj(s1, s2);       //调用fobj(string, string); const 被忽略
        fref(s1, s2);       //调用fref(const string&, const string&)
                            //将s1转换为const是允许的

        int a[10], b[42];
        fobj(a,b);          //调用f(int *, int*)
        fref(a,b);          //错误：数组类型不匹配


## 16.2.2 函数模板显示实参（**初始化模板的顺序问题**）

* **出现这种情况的原因：在某种情况下，编译器无法推断出模板实参的类型**

    比如：
            template <typename T1, typename T2, typename T3>
            T1 sum(T2, T3);

* 解决以上情况的方法：
  * (1)显示模板实参

        auto val3 = sum<long long>(i, lng);     //long long sum(int, long)

    此调用显示指定T1的类型。而T2和T3的类型则由编译器从i和lng的类型推断出来

    **注意：如果在template<typename T1, typename T2, typename T3>中T1与T3的位置发生调换，则上面的计算就是错误的因为，long long这个类型给了T3，之后函数无法判断返回值。**

  * (2)正常类型转换应用与显示指定的实参

    首先解释一下，定义的普通的函数，允许进行类型转换；那么，对于模板类型参数如果已经显示指定了函数的实参，也能进行正常的类型转换。

        long lng;
        compare(lng, 1024);         //错误：模板参数不匹配
        compare<long>(lng, 1024);   //正确：因为可进行类型转换
        compare<int>(lng, 1024);    //正确：因为可以进行类型转换

## 16.2.3 尾置返回类型与类型转换

* 示例：

        template <typename It>
        auto fcn(It beg, It end) -> decltype(*beg)
        {
            //处理序列
            return *beg;    //返回序列中一个元素的引用
        }

* 解释为什么这样定义能成功：由于尾置返回出现在参数列表之后，它可以使用函数的参数


* 实例化类模板

    当使用一个类模板时，我们必须提供额外信息。我们现在知道这些额外信息是**显式模板实参列表**，它们被绑定到模板参数。编译器使用这些模板实参来实例化出特定的类。

        Blob<int>ia;        //空Blob<int>
        Blob<int>ia2 = {0,1,2,3,4}//有5个元素的Blob<int>

  * 通用和特定的模板友好关系
        
    一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元：

        //前置声明，在将模板的一个特定实例声明为友元时要用到
        template<typename T>class Pal;
        class C{//C是一个普通的非模板类
            friend class Pal<C>;        //用类C实例化的Pal是C的一个友元
            //Pal2的所有实例都是C的友元；这种情况无须前置声明
            template <typename T> friend class Pal2;
        };

        template <typename T>class C2{ //C2本身是一个类模板
            //C2的每个实例将相同实例化的Pal声明为友元
            friend class Pal<T>;//Pal的模板声明必须在作用域之内
            //Pal2的所有实例都是C2的每个实例的友元，不需要前置声明
            template<typename X>friend class Pal2;
            //Pal3是一个非模板类，它是C2所有实例的友元
            friend class Pal3;  //不需要Pal3的前置声明
        };


### 类型转换与模板类型参数

主要讲的是，当调用模板类型时，实参与模板的形参不一致的时候可能发生类型转换，来适应调用。

### 16.2.2函数模板显式实参

在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。**当函数返回类型与参数列表中任何类型都不相同时，这种情况最常出现**

        //编译器无法推断T1，它未出现在函数参数列表中
        template<typename T1, typename T2, typename T3>

        T1 sum(T2,T3);

我们提供显式模板实参的方式与定义类模板实例的方式相同。**显式模板实参在尖括号**中给出，位于**函数命之后**，**实参列表之前**：

        T1是显式指定的，T2和T3是从函数实参类型推断而来的
         auto val3 = sum<long long>(i,lng);
         //long long sum(int , long)

此调用**显式指定T1**的类型。而**T2和T3的类型则由编译器从i和lng的类型推断**出来。而且显式模板实参按由左至右的顺序与对应的模板参数匹配：第一个模板实参与第一个模板参数匹配；第二个与第二个匹配，依次类推。只有尾部参数的显式模板实参可以忽略。

        template <typename T1, typename T2, typename T3>
        T3 alternative_sum(T2, T1);

        //以下调用错误
        auto val3 = alternative_sum<long long>(i, lng);
        //以下正确，因为显式指定了所有三个参数
        auto val2 = alternative_sum<long long, int, long>(i,lng);

### 16.2.3尾置返回类型与类型转换

当我们希望用户确定返回类型时，用显式模板实参表示模板函数的返回类型是很有效的。**通俗意思就是，函数的返回类型由用户自己决定，在返回时决定。**

        template <typename It>
        ??? &fcn(It beg, It end){
            //处理序列
            return *beg;//返回序列中一个元素的引用
        }

        //尾置返回允许我们在参数列表之后返回声明返回类型
        template <typename It>
        auto fcn(It beg, It end) -> decltype(*beg){
            //处理序列
            return *beg;    //返回序列中一个元素的引用
        }

  * 进行类型转换的标准库模板类

    有时我们无法直接获得所需要的类型。例如，我们向编写一个fcn**能返回值，而不是返回引用。**

    问题是，对于传递的参数的类型，我们不知道，所有的迭代操作都不会生成元素，只能生成元素的引用。

    **为了获得元素类型，我们可以使用标准库的类型转换模板**。这些模板定义在头文件type_traits中。

    本例中，我们可以使用remove_reference来脱去元素的引用，获得元素的原始类型。

        template<typename It>
        auto fcn2(It beg, It end)->
            typename remove_reference<decltype(*beg)>::type
            {
                //处理序列
                return *beg;
                //返回序列中一个元素的拷贝
            }


  * 引用折叠和右值引用参数

        template<typename T>void f3(T&&);

    假定i是一个int对象，我们可能认为像f3(i)这样的调用是不合法的。毕竟i是一个左值，**而通常我们不能将一个右值引用绑定到一个左值上**。但是，C++语言在正常绑定规则之外定义了两个例外规则，允许这种绑定。这两个例外规则是move这种标准库设施正确工作的基础。

        第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值(如i)传递给函数的右值引用参数，且此右值引用指向模板类型参数(如T&&)时，编译器推断模板类型参数为实参的左值引用类型。因此，当我们调用f3(i)时，编译器推断T的类型为int&,而非int。

        T被推断为int&看起来好像意味着f3的函数参数应该是一个类型int&的右值引用。

        通常，我们不能(直接)定义一个引用的引用。但是，通过类型别名或通过模板类型参数间接定义是可以的。

        在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建一个引用的引用，则这些引用形成了"折叠"。在所有情况下(除了一个例外外)，引用会折叠成一个普通的左值引用类型。在新标准中，折叠规则拓展到右值引用。只有一种特殊情况下引用会折叠成右值引用：右值引用的右值引用。即，对于一个给定类型X:

      * X& &,X& &&和X&& &都折叠成类型X&
      * 类型X&& &&折叠成X&&

    **注意：引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。**


### 16.2.7 转发

**注意：如果一个函数参数是指向模板类型参数的右值引用(如T&&)，它对应的实参的const属性和左值/右值属性将得到保持。**

## 16.5 模板特例化

* 定义函数模板特例化
* 函数重载与模板特例化
* 类模板特例化

    除了特例化函数模板，我们还可以特例化类模板。作为一个例子，我们将为标准库hash模板定义一个特例化版本，可以用它来将Sales_data对象保存在无序容器中。默认情况下，无序容器使用hash<key_type>来组织其元素，为了让我们自己的数据类型也能使用这种默认组织方式，**必须定义hash模板的一个特例化版本**。一个特例化hash类必须定义。**在定义此特例化版本的hash时，唯一复杂的地方是：必须在原模版定义所在的命名空间中特例化它。我们可以向命名空间添加成员，为了达到目的，首先必须打开命名空间**

        namespace std{
            //花括号对之间的任何定义都将成为命名空间std的一部分
        }//没有逗号，结尾
        namespace std{
            template<>//我们正在定义一个特例化版本，模板参数为Sales_data
            struct hash<Sales_data>{
                //用来散列一个无序容器的类型必须要定义下列类型
                typedef size_t result_type;
                typedef Sales_data argument_type;
                size_t operator()(const Sales_data& s) const;
                //我们的类使用合成的拷贝控制成员和默认构造函数
            };
            size_t
            hash<Sales_data>::operator()(const Sales_data& s)const
            {
                return hash<string>()(s.bookNo)^
                       hash<unsigned>()(s.units_sold)^
                       hash<double>()(s.revenue);
            }
        }//关闭std命名空间;注意：右花括号之后没有分号
* 类模板部分特例化

    **注意：我们只能部分特例化类模板，而不能部分特例化函数模板。**


* 特例化成员而不是类
* 